import Head from "next/head";
import Navigation from "./navigation";
import MetaMaskOnboarding from "@metamask/onboarding";
import detectEthereumProvider from "@metamask/detect-provider";
import { useState, useEffect, useRef } from "react";
import {
  connectWallet,
  disconnectWallet,
  getUserAccounts,
} from "../services/blockApi.service";

const Layout = ({ children }) => {
  // STATE

  const [isDisabled, setDisabled] = useState(false);
  const [accounts, setAccounts] = useState(null);
  const [provider, setProvider] = useState("");
  const [chainId, setChainId] = useState(null);
  const [message, setMessage] = useState("");
  const [networkName, setNetworkName] = useState("");
  const onboarding = useRef();

  // EFFECTS
  useEffect(async () => {
    if (!onboarding.current) {
      onboarding.current = new MetaMaskOnboarding();
    }
    if (MetaMaskOnboarding.isMetaMaskInstalled()) {
      const currentProvider = await detectEthereumProvider();
      if (currentProvider !== window.ethereum) {
        // If the provider returned by detectEthereumProvider is not the same as window.ethereum, something is overwriting it, perhaps another wallet.
        setMessage("Do you have multiple wallets installed?");
      }

      if (
        currentProvider &&
        localStorage.getItem("wallet-connected") !== null
      ) {
        try {
          setProvider(currentProvider);
          let accountsObj = await getUserAccounts(currentProvider);
          setAccounts(accountsObj);
          setMessage(accountsObj.status);
          setChainId(accountsObj.chainId);
          setNetworkName(accountsObj.networkName);

          window.ethereum.on("accountsChanged", (newAccnts) => {
            if (newAccnts > 0) window.location.reload();
          });
          window.ethereum.on("chainChanged", (newChain) => {
            if (newChain > 0) window.location.reload();
          });
        } catch (error) {
          setMessage("ERROR USEEFFECT:" + error?.message);
        }
      }
    } else {
      onboarding.current.startOnboarding();
    }

    return () => {
      window.ethereum.removeListener("accountsChanged", (newAccnts) => {
        if (newAccnts > 0) window.location.reload();
      });
      window.ethereum.removeListener("chainChanged", (newChain) => {
        if (newChain > 0) window.location.reload();
      });
    };
  }, []);

  // HANDLERS
  const handleConnect = async () => {
    let connObj = await connectWallet(provider);
    if (connObj) {
      console.log("CONNECT OBJ: ", connObj);
      setAccounts(connObj);
      setMessage(connObj.status);
      setChainId(connObj.chainId);
      setNetworkName(connObj.networkName);
    }
    // store in cache
    localStorage.setItem("wallet-connected", "CONNECTED");
    window.location.reload();
  };

  const handleDisconnect = () => {
    let obj = disconnectWallet(provider);
    if (obj) {
      console.log("Disconnect OBJ: ", obj);
      setAccounts("");
      setChainId("");
      setNetworkName("");
      setMessage(obj.status);
      // clear cache connection
      localStorage.clear();
    }
  };

  return (
    <>
      <Head>
        <title>NextWind</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Navigation
        handleConnect={handleConnect}
        accounts={accounts}
        handleDisconnect={handleDisconnect}
      />
      <main className="mx-auto">
        {/* use <section> tags in page level to seperate content */}
        {children}
        {/* EXAMPLE CONTENT STRUCTURE - section > div.container  */}
        <section>
          <div className="container mx-auto">
            {accounts && <p>Account: {accounts.address}</p>}
            {message && <p>STATUS MESSAGE: {message}</p>}
            {chainId && <p>chainId: {chainId}</p>}
            {networkName && <p>networkName: {networkName}</p>}
          </div>
        </section>
      </main>
    </>
  );
};

export default Layout;
